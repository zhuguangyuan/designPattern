# java内存分配
- 介绍一个工具 javap 
	- c 分解方法代码 显示每个方法具体的字节码
	- l 用于指定显示行号和局部变量列表
	- public/protected/package/private 用于指定显示哪种级别的类成员
	- verbose 用于指定显示更进一步的详细信息

- 局部变量(生命周期短，在栈区)
	- 形参
	- 方法内的局部变量
	- 代码块内的局部变量
 - 成员变量(Field,)
 	- 类变量，static修饰(注意static不能修饰外部类，或者局部变量/局部内部类)
 		- 定义，分配内存并给默认初始值，0/null
 		- 按顺序初始化
 	- 实例变量
 		- 初始化时机
 			- 定义时/非静态代码中
 			- 构造函数中
 			- 定义变量语句C被拆成声明语句C1和赋值语句C2，假设静态块中的赋值语句为C3，C2和C3会被提取到构造函数中，且位于其他构造语句之前。C2 C3的顺序和其在源程序中的排列顺序一致。
 	- 创建java对象时，系统总是先调用顶层父类的初始化操作，包括初始化块和构造器，然后依次向下调用所有父类的初始化操作，最终执行本类的初始化操作返回本类的实例.
 		- 注意构造器中this/super调用须在第一行代码
 		- this(args)显式调用本类重载构造函数
 		- super(args)显式调用父类构造函数
 		- 既没有this 也没有super调用则调用父类的无参构造器
 	- java编译时，会将父类方法转移到子类中，除非该方法被子类重写。但是父类实例变量不会转移到子类中，所以父类和子类可以出现同名实例变量。
 		- Father f = new Son(); Father,Son中都有变量i,方法A
 		- 当通过f访问i时访问到的是Father中的i,通过f访问A时访问到的是Son中的A
 		- f指向的对象中，包含了两块储存实例变量的区域，分别存储父类的实例i和子类的实例i

 		- 当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为其父类中所有实例变量分配内存，即使子类中定义了与父类中同名的实例变量。
 		- 为了在子类方法中访问父类中定义的、被隐藏的实例变量，或者为了在子类方法中调用父类中定义的、被覆盖的方法，可以使用super.作为限定来修饰这些实例变量和实例方法
 - final修饰符
