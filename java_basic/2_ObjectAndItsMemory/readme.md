# java内存分配
- 介绍一个工具 javap 
	- c 分解方法代码 显示每个方法具体的字节码
	- l 用于指定显示行号和局部变量列表
	- public/protected/package/private 用于指定显示哪种级别的类成员
	- verbose 用于指定显示更进一步的详细信息

- 局部变量(生命周期短，在栈区)
	- 形参
	- 方法内的局部变量,需显式赋值
	- 代码块内的局部变量，需显式赋值
- 成员变量(Field,非final的变量系统会在分配内存时指定默认值0/null/false
 )
 	- 类变量，static修饰(注意static不能修饰外部类，或者局部变量/局部内部类)
 		- 定义，分配内存并给默认初始值，0/null
 		- 按顺序初始化
 	- 实例变量
 		- 初始化时机
 			- 定义时/非静态代码中
 			- 构造函数中
 			- 定义变量语句C被拆成声明语句C1和赋值语句C2，假设静态块中的赋值语句为C3，C2和C3会被提取到构造函数中，且位于其他构造语句之前。C2 C3的顺序和其在源程序中的排列顺序一致。
 	- 创建java对象时，系统总是先调用顶层父类的初始化操作，包括初始化块和构造器，然后依次向下调用所有父类的初始化操作，最终执行本类的初始化操作返回本类的实例.
 		- 注意构造器中this/super调用须在第一行代码
 		- this(args)显式调用本类重载构造函数
 		- super(args)显式调用父类构造函数
 		- 既没有this 也没有super调用则调用父类的无参构造器
 	- java编译时，会将父类方法转移到子类中，除非该方法被子类重写。但是父类实例变量不会转移到子类中，所以父类和子类可以出现同名实例变量。
 		- Father f = new Son(); Father,Son中都有变量i,方法A
 		- 当通过f访问i时访问到的是Father中的i,通过f访问A时访问到的是Son中的A
 		- f指向的对象中，包含了两块储存实例变量的区域，分别存储父类的实例i和子类的实例i

 		- 当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为其父类中所有实例变量分配内存，即使子类中定义了与父类中同名的实例变量。
 		- 为了在子类方法中访问父类中定义的、被隐藏的实例变量，或者为了在子类方法中调用父类中定义的、被覆盖的方法，可以使用super.作为限定来修饰这些实例变量和实例方
- final修饰符
 	- 必须在初始化区域代码中显式指定初始值
 		- 类变量需在定义时或者静态初始化块中指定
 		- 实例变量需在定义时/非静态初始化块/构造函数中指定
 		- 修饰局部变量也需显式指定初始值。但是局部变量本来就要求显式指定初始值
 	- 被final修饰的变量，如果定义该final变量时就指定初始值，且这个初始值在编译时就可以确定下来，那么这个final变量将不再是一个变量，系统会将他当成“宏变量”处理。即所有出现该变量的地方都将被替换成对应的值。
 		- 注意需在定义时赋值才有“宏替换”效果，若是先定义，再在代码块中或者构造函数中指定初始值则无"宏替换"效果。
 		- 指定初始值的方式可以是直接量，也可以是算术表达式，或者字符串连接运算。这些都能在编译时确定结果
 		- 指定初始值中包含方法调用则不可，此时final变量会在静态初始化块中初始化，而不会被当成“宏变量”处理。
 		- java会缓存所有曾经用过的字符串直接量。String a = "字符串";则"字符串"会被缓存在字符串池中，再次执行String b = "字符串"，则b会直接指向池中的“字符串”，所有a == b
 	- 在任何内部类中访问的局部变量都应该使用final修饰。
 		- 原因是内部类可能产生隐式“闭包”，使得局部变量脱离他所在的方法继续存在，这将导致局部变量脱离了他的作用域(本方法内)。此时如果没有final修饰，变量的值将可以随意改变，从而引起混乱。