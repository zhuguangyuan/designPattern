# designPattern
java 设计模式
- 六大设计原则
	- 依赖倒置原则
		- 高层模块不应该依赖低层模块，两者都应该依赖抽象
		- 抽象不应该依赖细节，细节应该依赖抽象
		- 面向接口编程
		- 测试驱动开发TDD 
			- JMock工具
		- 依赖的3种写法
			- 构造函数传递依赖对象==构造函数注入
			- setter方法传递依赖对象==setter依赖注入
			- 接口声明依赖对象==接口注入
		- 最佳实践
			- 每个类尽量都有接口或者抽象类，或者两者都具备
			- 变量的表面类型尽量是接口或者抽象类(注意使用clone()方法时得是具体类)
			- 任何类都不应该从具体类派生(尽量不)
			- 尽量不要覆写基类的已经实现了的方法
			- 结合里氏替换原则使用
				- 接口：负责定义public属性和方法，并声明和其他对象的依赖关系
				- 抽象类：负责公共构造部分的实现
				- 实现类：负责准确地实现业务逻辑，同时在适当的地方对父类进行细化。
	- 里氏替换原则
		- 调用父类对象的地方，全部改成子类，运行效果不变
		- 类的继承在Is-A的情况下才使用，不可滥用
	- 接口隔离原则
		- 接口尽量细化，同时接口中的方法尽量少(区别单一职责原则(从业务逻辑上讲))
		- 提供给几个模块就应该有几个接口，而不是建立庞大臃肿的接口
	- 单一职责原则
		- 

- 创建型模式
- 结构型模式
	- 代理模式
		- 定义
			- 代理对象存在的价值主要在于拦截对真实业务对象的访问
			- 代理对象应该具有和目标对象相同的方法
		- java中的代理
			- java.lang.reflect.Proxy
				static Object newProxyInstance(
					ClassLoader loader, 		// 用哪个类加载器
					Class<T>[] interfaces,		// 哪个对象的代理对象
					InvocationHandler handler 	// 代理对象要做什么
					)
			- 上述方法的 interfaces 参数说明，要生成代理的真实对象，应该是实现了某些接口的类
				- 这些接口定义了这个对象所具有的行为
			- InvocationHandler接口只定义了一个invoke方法，因此对于这样的接口，我们不用单独去定义一个类来实现该接口，
	         	- 而是直接使用一个匿名内部类来实现该接口，
	         	new InvocationHandler() {
	         		Object object = new RealSubject();// 代理者要代理的对象
	         		// 客户端调用的所有真实对象的方法都经过此方法的过滤
	         		// 开发者可以在此检查用户权限，动态为某个对象增加额外功能等
	         		public Object invoke(Proxy proxy, Method method, String[] args) throws Throwable {
	         			return (Object) method.invoke(this.object, args);
	         		}
	         	}
	    - 应用实例
	   		- 在字符过滤器中使用动态代理解决字符乱码问题
	   		- 在字符过滤器中使用动态代理压缩服务器响应的内容后再传输到客户端
	   		- [实例代码链接](https://www.cnblogs.com/xdp-gacl/p/3971367.html) 
	   		- AOP编程：本质是在一系列纵向的控制流程中，把那些相同的子流程提取成一个横向的面
	   		- 拦截器原理
	- 装饰器模式
		- 类继承的一种替代方案
		- 区别于类继承的为类静态地增加功能，装饰模式是为类动态地增加或者减少功能。
		- 代理模式和装饰模式的区别
			- 装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口，不同点则是代理模式着重
				对代理过程的控制，而装饰模式则是对类的
			- 代理模式是把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以
				调用真实角色，以及是否对发送到真实角色的消息进行变形处理，它不对被主题角色（也就
				是被代理类）的功能做任何处理，保证原汁原味的调用。代理模式使用到极致开发就是
				AOP，这是各位采用Spring架构开发必然要使用到的技术，它就是使用了代理和反射的技术。
			- 装饰模式是在要保证接口不变的情况下加强类的功能，它保证的是被修饰的对象功能比
				原始对象丰富（当然，也可以减弱），但不做准入条件判断和准入参数过滤，如是否可以执
				行类的功能，过滤输入参数是否合规等，这不是装饰模式关心的。
		- 装饰模式和适配器模式的区别
			- 都是包装作用，都是通过委托作用实现其功能
			- 不同的是装饰模式装饰的是自家兄弟，接口相同(功能增强)；适配器模式适配的是客人，将客人适配成自家人，接口不同(功能转换)
	- 适配器模式
	- Structual_Bridge

功能进行加强或减弱，它着重类的功能变化

- 行为型模式
